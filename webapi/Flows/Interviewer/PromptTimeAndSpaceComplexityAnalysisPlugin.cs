// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.AI;
using Microsoft.SemanticKernel.AI.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.AI.OpenAI;
using Microsoft.SemanticKernel.Experimental.Orchestration;
using Microsoft.SemanticKernel.Orchestration;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace CopilotChat.WebApi.Flows.Interviewer;

public sealed class PromptTimeAndSpaceComplexityAnalysisPlugin
{
    private const string Problem = "problem_statement";
    private const string Solution = "_solution_code_implementation";
    private const string Delimiter = "```";
    private const string Goal = "Ask user to analyze the time and space complexity of their final solution's code implementation.";

    private const string SystemPrompt =
        @$"[Instruction]
The user has provided the final {Solution} to the {Problem}.
Your only task is to get the time and space complexity analysis from the user.
You can only ask user to analyze the time and space complexity based on their solution.
If the user responds with anything other than a time complexity or a space complexity, say that you don't know.
You are not allowed to give the analysis to the user.

The last step is to provide the user with a JSON object with time complexity and the space complexity. This object will be of the format [JSON format].
You will reply to the user with this JSON object AFTER they confirm their final time complexity and space complexity.
IMPORTANT: You will reply with the JSON object ONLY. This object will be wrapped in the delimiter {Delimiter}. DO NOT INCLUDE ANY OTHER WORDS OR EXPLANATIONS.
[End Instruction]

[JSON format]
{{
    ""timeComplexity"": <time complexity>,
    ""spaceComplexity"": <space complexity>
}}
[END JSON format]

[example]
    User: I think the time complexity is O(n) since I iterate through the array exactly once and the space complexity is O(1) since there's no extra space used.
    Assistant: That's right. Your solution has an optimal time and space complexity. Can you confirm your final time complexity is O(n) and space complexity is O(1)?
    User: Yes.
    Assistant:
        {Delimiter}
        {{
            ""timeComplexity"": ""O(n)"",
            ""spaceComplexity"": ""O1)""
        }}
        {Delimiter}
[END example]
";

    private readonly IChatCompletion _chat;

    private int MaxTokens { get; set; } = 1024;

    private readonly AIRequestSettings _chatRequestSettings;

    public PromptTimeAndSpaceComplexityAnalysisPlugin(IKernel kernel)
    {
        this._chat = kernel.GetService<IChatCompletion>();
        this._chatRequestSettings = new OpenAIRequestSettings
        {
            MaxTokens = this.MaxTokens,
            StopSequences = new List<string>() { "Observation:" },
            Temperature = 0
        };
    }

    [SKFunction]
    [Description("This function is used to get from user the time and space complexity to the coding problem")]
    [SKName("PromptComplexity")]
    public async Task<string> PromptComplexityAsync(
        [SKName("problem_statement")][Description("The problem statement generated by the interviewer")] string problem_statement,
        SKContext context)
    {
        var chat = this._chat.CreateNewChat(SystemPrompt);
        chat.AddUserMessage(Goal);

        ChatHistory? chatHistory = context.GetChatHistory();
        if (chatHistory?.Any() ?? false)
        {
            chat.Messages.AddRange(chatHistory);
        }

        context.Variables.TryGetValue("_solution_code_implementation", out string solution);
        context.Variables["_solution_code_implementation"] = solution;

        var response = await this._chat.GenerateMessageAsync(chat, this._chatRequestSettings).ConfigureAwait(false);

        var jsonRegex = new Regex($"{Delimiter}\\s*({{.*}})\\s*{Delimiter}", RegexOptions.Singleline);
        var match = jsonRegex.Match(response);

        if (match.Success)
        {
            var json = match.Groups[1].Value;
            var complexityJson = JsonConvert.DeserializeObject<JObject>(json);

            context.Variables["time_complexity"] = complexityJson["timeComplexity"].Value<string>();
            context.Variables["space_complexity"] = complexityJson["spaceComplexity"].Value<string>();

            return "User has provided their time and space complexity analysis.";
        }

        context.PromptInput();
        return response;
    }
}
